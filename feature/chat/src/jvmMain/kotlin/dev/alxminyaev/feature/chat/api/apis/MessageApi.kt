/**
 * Chat service
 * Chat service
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: alxminyaev@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package dev.alxminyaev.feature.chat.api.apis


import com.alxminyaev.tool.error.exceptions.UnauthorizedException
import com.alxminyaev.tool.error.exceptions.ValidationDataException
import com.google.gson.Gson
import dev.alxminyaev.feature.chat.api.Paths
import dev.alxminyaev.feature.chat.api.models.CreateMessageRequest
import dev.alxminyaev.feature.chat.api.models.EntityLongCreatedResponse
import dev.alxminyaev.feature.chat.api.toMessageListApi
import dev.alxminyaev.feature.chat.model.DataLimit
import dev.alxminyaev.feature.chat.model.SideOfChat
import dev.alxminyaev.feature.chat.usecase.message.GetMessagesFromChat
import dev.alxminyaev.feature.chat.usecase.message.SendMessageInChatUseCase
import dev.alxminyaev.tool.webServer.utils.User
import dev.alxminyaev.tool.webServer.utils.user
import io.ktor.application.*
import io.ktor.auth.*
import io.ktor.http.*
import io.ktor.http.content.*
import io.ktor.locations.*
import io.ktor.request.*
import io.ktor.response.*
import io.ktor.routing.*
import io.ktor.util.*
import io.ktor.utils.io.*
import io.ktor.utils.io.jvm.javaio.*
import io.ktor.utils.io.streams.*
import org.kodein.di.instance
import org.kodein.di.ktor.di
import java.lang.IllegalStateException

@KtorExperimentalLocationsAPI
fun Route.MessageApi() {
    val gson = Gson()
    val empty = mutableMapOf<String, Any?>()

    authenticate {
        get<Paths.getMessagesByChatId> { param: Paths.getMessagesByChatId ->
            val useCase by di().instance<GetMessagesFromChat>()
            val messages = useCase.invoke(
                forUserId = call.user.id,
                chatId = param.chatId,
                dataLimit = DataLimit(param.offset, param.limit)
            )

            call.respond(messages.toMessageListApi())
        }
    }

    authenticate {
        route("/api/v1/chat/{chat_id}/user/message") {
            post {
                val user = call.principal<User>() ?: throw UnauthorizedException()
                val useCase by di().instance<SendMessageInChatUseCase>()
                val chat = SideOfChat.Chat(
                    call.parameters["chat_id"]?.toLong()
                        ?: throw ValidationDataException(message = "chat_id must be set")
                )
                val contentType = call.request.contentType()
                val messageId = when {
                    contentType.match(ContentType.MultiPart.FormData) -> {
                        val multiPartData = call.receiveMultipart()
                        var text: String? = null
                        val files = linkedMapOf<String, ByteReadChannel>()

                        multiPartData.forEachPart { part ->
                            when (part) {
                                is PartData.FormItem -> {
                                    if (part.name == "text" && text != null) {
                                        throw ValidationDataException()
                                    }
                                    text = part.value
                                }
                                is PartData.FileItem -> {
                                    if (part.name == "files") {
                                        val fileName = part.originalFileName ?: throw ValidationDataException()
                                        val inputStream = part.streamProvider().toByteReadChannel()
                                        files[fileName] = inputStream
                                    }
                                }
                                is PartData.BinaryItem -> {
                                    throw IllegalStateException()
                                }
                                else -> {

                                }
                            }
//                            part.dispose()
                        }
                        useCase.invoke(
                            creatorId = user.id,
                            sender = SideOfChat.User(user.id),
                            receiver = chat,
                            text = text,
                            files = files
                        )

                    }
                    else -> {
                        val obj = call.receive<CreateMessageRequest>()
                        useCase.invoke(
                            creatorId = user.id,
                            sender = SideOfChat.User(user.id),
                            receiver = chat,
                            text = obj.text
                        )
                    }
                }
                call.respond(EntityLongCreatedResponse(messageId))
            }
        }
    }

}
